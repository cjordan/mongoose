// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

use std::path::PathBuf;

use chrono::Utc;
use itertools::Itertools;
use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    static ref RE_GPUBOX_BAND: Regex = Regex::new(r"gpubox(0)?(?P<band>\d+)").unwrap();
}

#[derive(Clone, Copy, Debug)]
pub enum RtsMode {
    Patch,
    Peel {
        /// The number of ionospheric calibrators.
        num_cals: u32,
        /// The number of calibrators to peel.
        num_peel: u32,
    },
}

#[derive(Debug)]
pub struct RtsParams {
    /// The type of RTS processing we're doing.
    pub mode: RtsMode,
    /// The directory where the observation's gpubox files are.
    pub base_dir: PathBuf,
    /// The metafits file associated with the observation.
    pub metafits: PathBuf,
    /// Path to the sky model source list.
    pub source_catalogue_file: PathBuf,
    /// The observation ID. Should have 10 digits.
    pub obsid: u32,
    pub obs_image_centre_ra: f64,
    pub obs_image_centre_dec: f64,
    /// Output time resolution, or the cadence at which data is dumped
    /// [seconds]. CorrDumpTime in the RTS.
    pub time_resolution: f64,
    /// Fine channel resolution [MHz]
    pub fine_channel_width_mhz: f64,
    /// The number of fine channels per coarse-band channel.
    pub num_fine_channels: u32,
    /// The number of fine frequency channels to average together during
    /// processing (FscrunchChan)
    pub f_scrunch: u8,
    /// The magic freq. calculated with:
    ///
    /// centre_freq - coarse_channel_bandwidth/2 - fine_channel_bandwidth/2
    ///
    /// (ObservationFrequencyBase)
    pub base_freq: f64,
    /// Which coarse-band channels to use during RTS processing (SubBandIDs)
    pub subband_ids: Vec<u8>,
    /// The number of primary calibrators to use (NumberOfCalibrators)
    pub num_primary_cals: u32,
    pub do_rfi_flagging: bool,
    pub corr_dumps_per_cadence: u32,
    pub num_integration_bins: u32,
    pub num_iterations: u32,
}

impl std::fmt::Display for RtsParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(
            f,
            r#"// RTS in file to patch obsid {}
// Generated by mongoose v{version}
// on {time} UTC

FscrunchChan={fscrunch}

SubBandIDs={subband_ids}

StartProcessingAt=0

StorePixelMatrices=0

generateDIjones={generate_di_jones}
useStoredCalibrationFiles={use_stored_calibration}

applyDIcalibration=1
doMWArxCorrections=1

ReadMetafitsFile=1
MetafitsFilename={metafits}
BaseFilename={base_dir}/*_gpubox
ImportCotterFlags=1
ImportCotterBasename={base_dir}/RTS_{obsid}

doRFIflagging={rfi}
useFastPrimaryBeamModels=1

CorrDumpTime={time_res}
CorrDumpsPerCadence={cdpc}
NumberOfIntegrationBins={num_int_bins}
NumberOfIterations={num_ints}

ObservationFrequencyBase={base_freq}
NumberOfChannels={num_fine_channels}
ChannelBandwidth={fine_channel_bandwidth_mhz}

ObservationImageCentreRA={ra}
ObservationImageCentreDec={dec}
// Set these if delays are not in the metafits.
// ObservationPointCentreHA=
// ObservationPointCentreDec=

DoCalibration=1
SourceCatalogueFile={srclist}
NumberOfCalibrators={num_primary_cals}
{peel_only}
ReadGpuboxDirect=1
UsePacketInput=0
UseThreadedVI=0
doRawDataCorrections=1
// Necessary?
ReadAllFromSingleFile=

// Magic follows.
// MaxFrequency [MHz, float]: Used to set size of uv cells for gridding. Also
// affects binning of baselines by setting maximum decorrelation. Default is 300
// MHz.
MaxFrequency=200

// array_file.txt doesn't exist, but currently, the RTS will not
// run without it!
ArrayFile=array_file.txt
ArrayNumberOfStations=128

// Heaven help you if you're not using the MWA.
ArrayPositionLat=-26.70331940
ArrayPositionLong=116.67081524

calBaselineMin=20.0
calShortBaselineTaper=40.0

// ImageOversampling [float]: Sets oversampling of imaging pixel. Default value is 3.
ImageOversampling=3
"#,
            obsid = self.obsid,
            version = env!("CARGO_PKG_VERSION"),
            time = Utc::now().format("%Y-%m-%d %H:%M:%S"),
            fscrunch = self.f_scrunch,
            subband_ids = self.subband_ids.iter().map(|x| format!("{}", x)).join(","),
            generate_di_jones = match &self.mode {
                RtsMode::Patch => 1,
                RtsMode::Peel { .. } => 0,
            },
            use_stored_calibration = match &self.mode {
                RtsMode::Patch => 0,
                RtsMode::Peel { .. } => 1,
            },
            metafits = self.metafits.display(),
            base_dir = self.base_dir.display(),
            rfi = if self.do_rfi_flagging { 1 } else { 0 },
            time_res = self.time_resolution,
            cdpc = self.corr_dumps_per_cadence,
            num_int_bins = self.num_integration_bins,
            num_ints = self.num_iterations,
            base_freq = self.base_freq,
            num_fine_channels = self.num_fine_channels,
            fine_channel_bandwidth_mhz = self.fine_channel_width_mhz,
            ra = self.obs_image_centre_ra,
            dec = self.obs_image_centre_dec,
            srclist = self
                .source_catalogue_file
                .to_str()
                .expect("Couldn't convert self.source_catalogue_file to string!"),
            num_primary_cals = self.num_primary_cals,
            // Peel-only options.
            peel_only = match &self.mode {
                RtsMode::Patch => "".to_string(),
                RtsMode::Peel { num_cals, num_peel } => format!(
                    "UpdateCalibratorAmplitudes=1\n\
                     NumberOfIonoCalibrators={}\n\
                     NumberOfSourcesToPeel={}\n\
                     writeVisToUVFITS=1\n",
                    num_cals, num_peel
                ),
            },
        )
    }
}
