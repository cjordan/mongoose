// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

use std::path::PathBuf;

use chrono::Utc;
use itertools::Itertools;
use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    static ref RE_GPUBOX_BAND: Regex = Regex::new(r"gpubox(0)?(?P<band>\d+)").unwrap();
}

#[derive(Clone, Copy, Debug)]
pub enum RtsMode {
    Patch,
    Peel {
        /// The number of ionospheric calibrators.
        num_cals: u32,
        /// The number of calibrators to peel.
        num_peel: u32,
    },
}

#[derive(Debug)]
pub struct RtsParams {
    /// The type of RTS processing we're doing.
    pub mode: RtsMode,

    // File related.
    /// The directory where the observation's gpubox files are.
    pub base_dir: PathBuf,

    /// The directory where the observation's gpubox files are.
    pub base_filename: String,

    /// The metafits file associated with the observation.
    pub metafits: Option<PathBuf>,

    /// Are we using the mwaf files?
    pub use_cotter_flags: bool,

    /// Path to the sky model source list.
    pub source_catalogue_file: PathBuf,

    /// doRFIflagging
    pub do_rfi_flagging: bool,

    /// doMWArxCorrections
    pub do_rx_corrections: bool,

    /// doRawDataCorrections
    pub do_raw_data_corrections: bool,

    /// ReadGpuboxDirect
    pub read_gpubox_direct: bool,

    /// ReadAllFromSingleFile
    pub read_all_from_single_file: bool,

    /// AddNodeNumberToFilename
    pub add_node_number_to_filename: bool,

    /// The path to the FEE beam HDF5 file. If it's not specified, assume we're
    /// using the analytic beam.
    pub fee_beam_file: Option<PathBuf>,

    // Observation related.
    /// The observation ID. Should have 10 digits.
    pub obsid: u32,

    /// ObservationImageCentreRA
    pub obs_image_centre_ra: f64,

    /// ObservationImageCentreDec
    pub obs_image_centre_dec: f64,

    /// Output time resolution, or the cadence at which data is dumped [seconds]
    /// (CorrDumpTime)
    pub corr_dump_time: f64,

    /// CorrDumpsPerCadence
    pub corr_dumps_per_cadence: u32,

    /// NumberOfIntegrationBins
    pub num_integration_bins: u32,

    /// The number of times to run the CML loop.
    pub num_iterations: u32,

    /// Fine channel resolution [MHz]
    pub fine_channel_width_mhz: f64,

    /// The number of fine channels per coarse-band channel.
    pub num_fine_channels: u32,

    /// The number of fine frequency channels to average together during
    /// processing (FscrunchChan)
    pub f_scrunch: u8,

    /// The magic freq. calculated with:
    ///
    /// centre_freq - coarse_channel_bandwidth/2 - fine_channel_bandwidth/2
    ///
    /// (ObservationFrequencyBase)
    pub base_freq: f64,

    /// Which coarse-band channels to use during RTS processing (SubBandIDs)
    pub subband_ids: Vec<u8>,

    /// The number of primary calibrators to use (NumberOfCalibrators)
    pub num_primary_cals: u32,
}

impl std::fmt::Display for RtsParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(
            f,
            r#"// RTS in file to patch obsid {}
// Generated by mongoose v{version}
// on {time} UTC

FscrunchChan={fscrunch}

SubBandIDs={subband_ids}

StartProcessingAt=0

DoCalibration=1
generateDIjones={generate_di_jones}
useStoredCalibrationFiles={use_stored_calibration}
applyDIcalibration=1

BaseFilename={base_dir}/{base_filename}
{metafits}
{cotter}
doRFIflagging={rfi}
doMWArxCorrections={do_rx_corrections}
doRawDataCorrections={do_raw_data_corrections}
ReadGpuboxDirect={read_gpubox_direct}
ReadAllFromSingleFile={read_all_from_single_file}
AddNodeNumberToFilename={add_node_number_to_filename}
UsePacketInput=0
UseThreadedVI=0

{beam}

CorrDumpTime={time_res}
CorrDumpsPerCadence={cdpc}
NumberOfIntegrationBins={num_int_bins}
NumberOfIterations={num_ints}

ObservationFrequencyBase={base_freq}
NumberOfChannels={num_fine_channels}
ChannelBandwidth={fine_channel_bandwidth_mhz}

ObservationImageCentreRA={ra}
ObservationImageCentreDec={dec}
// Set these if delays are not in the metafits.
// ObservationPointCentreHA=
// ObservationPointCentreDec=

SourceCatalogueFile={srclist}
NumberOfCalibrators={num_primary_cals}
{peel_only}

// Magic follows.
// MaxFrequency [MHz, float]: Used to set size of uv cells for gridding. Also
// affects binning of baselines by setting maximum decorrelation. Default is 300
// MHz.
MaxFrequency=200

// array_file.txt doesn't exist, but currently, the RTS will not run without it!
ArrayFile=array_file.txt
ArrayNumberOfStations=128

// Heaven help you if you're not using the MWA.
ArrayPositionLat=-26.70331940
ArrayPositionLong=116.67081524

calBaselineMin=20.0
calShortBaselineTaper=40.0

// ImageOversampling [float]: Sets oversampling of imaging pixel. Default value
// is 3.
ImageOversampling=3

// Store pixel beam weights along with intensity. Required if subsequently
// integrating images using integrate_image utility. Images will be 4X greater
// data volume.
StorePixelMatrices=0
"#,
            obsid = self.obsid,
            version = env!("CARGO_PKG_VERSION"),
            time = Utc::now().format("%Y-%m-%d %H:%M:%S"),
            fscrunch = self.f_scrunch,
            subband_ids = self.subband_ids.iter().map(|x| format!("{}", x)).join(","),
            generate_di_jones = match &self.mode {
                RtsMode::Patch => 1,
                RtsMode::Peel { .. } => 0,
            },
            use_stored_calibration = match &self.mode {
                RtsMode::Patch => 0,
                RtsMode::Peel { .. } => 1,
            },
            metafits = match &self.metafits {
                Some(m) => format!(
                    "ReadMetafitsFile=1\n\
                     MetafitsFilename={}",
                    m.display()
                ),
                None => "ReadMetafitsFile=0".to_string(),
            },
            base_dir = self.base_dir.display(),
            base_filename = self.base_filename,
            cotter = if self.use_cotter_flags {
                format!(
                    "ImportCotterFlags=1\n\
                     ImportCotterBasename={}/RTS_{}",
                    self.base_dir.display(),
                    self.obsid
                )
            } else {
                "ImportCotterFlags=0".to_string()
            },
            rfi = if self.do_rfi_flagging { 1 } else { 0 },
            do_rx_corrections = if self.do_rx_corrections { 1 } else { 0 },
            do_raw_data_corrections = if self.do_raw_data_corrections { 1 } else { 0 },
            read_gpubox_direct = if self.read_gpubox_direct { 1 } else { 0 },
            read_all_from_single_file = if self.read_all_from_single_file { 1 } else { 0 },
            add_node_number_to_filename = if self.add_node_number_to_filename {
                1
            } else {
                0
            },
            beam = if let Some(f) = &self.fee_beam_file {
                format!(
                    "// FEE beam\n\
                     TileBeamType=1\n\
                     hdf5Filename={}",
                    f.display()
                )
            } else {
                "// Analytic beam\n\
                 useFastPrimaryBeamModels=1"
                    .to_string()
            },
            time_res = self.corr_dump_time,
            cdpc = self.corr_dumps_per_cadence,
            num_int_bins = self.num_integration_bins,
            num_ints = self.num_iterations,
            base_freq = self.base_freq,
            num_fine_channels = self.num_fine_channels,
            fine_channel_bandwidth_mhz = self.fine_channel_width_mhz,
            ra = self.obs_image_centre_ra,
            dec = self.obs_image_centre_dec,
            srclist = self
                .source_catalogue_file
                .to_str()
                .expect("Couldn't convert self.source_catalogue_file to string!"),
            num_primary_cals = self.num_primary_cals,
            // Peel-only options.
            peel_only = match &self.mode {
                RtsMode::Patch => "".to_string(),
                RtsMode::Peel { num_cals, num_peel } => format!(
                    "UpdateCalibratorAmplitudes=1\n\
                     NumberOfIonoCalibrators={}\n\
                     NumberOfSourcesToPeel={}\n\
                     writeVisToUVFITS=1",
                    num_cals, num_peel
                ),
            },
        )
    }
}
